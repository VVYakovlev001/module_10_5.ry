import os
import time
import multiprocessing
from turtledemo.penrose import start


def read_info(name): # где name название файла
    all_data = [] # создаем пустую папку
    with open(name,"r") as file: # открываем файл для чтения
        while True:
            line = file.readline() # Читает файл целиком, получает список строк из файла
            if not line: # если строка ничего не содержит, то она переходит к следующей итерации цикла
                break
                all_data.append(line.strip()) # добавление файлов в папку all_data
                return all_data # возврат

if __name__ =="__main__":

    filenames = [f'./file {number}.txt' for number in range(1, 5)] #
    # линейный вызов
    start.time = time.time() # счетчик на 0
    for filename in filenames:
        read_info(filename) # вызов функции
    prod_time1 = time.time() - start.time # разница между началом и концом работы
    print(f'Время выполнения линейного вызова {prod_time1: .2f} секунд')
# Время выполнения линейного вызова  6.675332069396973 секунд
    # Время выполнения много процессного вызова: 2.65 секунд

# Много процессный вызов
    start_time = time.time() # счетчик на 0
    with multiprocessing.Pool(processes=4) as pool: # Pool объект, который предлагает
        # удобные средства распараллеливания выполнения функции по нескольким входным
        # значениям, распределяя входные данные по процессам
        pool.map(read_info, filenames) # вызова функции используйте метод map,
        # передав в него функцию read_info и список названий файлов.
    prod_time2 = time.time() - start_time # разница между началом и концом работы
    print(f'Время выполнения много процессного вызова: {prod_time2: .2f} секунд')

name = ['file 1.txt','file 2.txt','file 3.txt','file 4.txt']
'''  
Создайте функцию read_info(name), где name - название файла. Функция должна:
Создавать локальный список all_data.
Открывать файл name для чтения.
Считывать информацию построчно (readline), пока считанная строка не окажется пустой.
Во время считывания добавлять каждую строку в список all_data.
Этих операций достаточно, чтобы рассмотреть преимущество многопроцессного
 выполнения программы над линейным.
Создайте список названий файлов в соответствии с названиями файлов архива.
Вызовите функцию read_info для каждого файла по очереди (линейно) и измерьте
время выполнения и выведите его в консоль.
Вызовите функцию read_info для каждого файла, используя многопроцессный подход:
 контекстный менеджер with и объект Pool. 
Для вызова функции используйте метод map, передав в него функцию read_info и 
список названий файлов. Измерьте время выполнения и выведите его в консоль.
Для избежания некорректного вывода запускайте линейный вызов и многопроцессный по 
отдельности, предварительно закомментировав другой.
  '''